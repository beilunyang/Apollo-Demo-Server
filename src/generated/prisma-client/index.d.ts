// Code generated by Prisma (prisma@1.23.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  logError: (where?: LogErrorWhereInput) => Promise<boolean>;
  logSession: (where?: LogSessionWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userRefreshToken: (where?: UserRefreshTokenWhereInput) => Promise<boolean>;
  verificationCode: (where?: VerificationCodeWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  logError: (where: LogErrorWhereUniqueInput) => LogErrorPromise;
  logErrors: (
    args?: {
      where?: LogErrorWhereInput;
      orderBy?: LogErrorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<LogError>;
  logErrorsConnection: (
    args?: {
      where?: LogErrorWhereInput;
      orderBy?: LogErrorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LogErrorConnectionPromise;
  logSession: (where: LogSessionWhereUniqueInput) => LogSessionPromise;
  logSessions: (
    args?: {
      where?: LogSessionWhereInput;
      orderBy?: LogSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<LogSession>;
  logSessionsConnection: (
    args?: {
      where?: LogSessionWhereInput;
      orderBy?: LogSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LogSessionConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  userRefreshToken: (
    where: UserRefreshTokenWhereUniqueInput
  ) => UserRefreshTokenPromise;
  userRefreshTokens: (
    args?: {
      where?: UserRefreshTokenWhereInput;
      orderBy?: UserRefreshTokenOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserRefreshToken>;
  userRefreshTokensConnection: (
    args?: {
      where?: UserRefreshTokenWhereInput;
      orderBy?: UserRefreshTokenOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserRefreshTokenConnectionPromise;
  verificationCode: (
    where: VerificationCodeWhereUniqueInput
  ) => VerificationCodePromise;
  verificationCodes: (
    args?: {
      where?: VerificationCodeWhereInput;
      orderBy?: VerificationCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<VerificationCode>;
  verificationCodesConnection: (
    args?: {
      where?: VerificationCodeWhereInput;
      orderBy?: VerificationCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VerificationCodeConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createLogError: (data: LogErrorCreateInput) => LogErrorPromise;
  updateLogError: (
    args: { data: LogErrorUpdateInput; where: LogErrorWhereUniqueInput }
  ) => LogErrorPromise;
  updateManyLogErrors: (
    args: { data: LogErrorUpdateManyMutationInput; where?: LogErrorWhereInput }
  ) => BatchPayloadPromise;
  upsertLogError: (
    args: {
      where: LogErrorWhereUniqueInput;
      create: LogErrorCreateInput;
      update: LogErrorUpdateInput;
    }
  ) => LogErrorPromise;
  deleteLogError: (where: LogErrorWhereUniqueInput) => LogErrorPromise;
  deleteManyLogErrors: (where?: LogErrorWhereInput) => BatchPayloadPromise;
  createLogSession: (data: LogSessionCreateInput) => LogSessionPromise;
  updateLogSession: (
    args: { data: LogSessionUpdateInput; where: LogSessionWhereUniqueInput }
  ) => LogSessionPromise;
  updateManyLogSessions: (
    args: {
      data: LogSessionUpdateManyMutationInput;
      where?: LogSessionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertLogSession: (
    args: {
      where: LogSessionWhereUniqueInput;
      create: LogSessionCreateInput;
      update: LogSessionUpdateInput;
    }
  ) => LogSessionPromise;
  deleteLogSession: (where: LogSessionWhereUniqueInput) => LogSessionPromise;
  deleteManyLogSessions: (where?: LogSessionWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserRefreshToken: (
    data: UserRefreshTokenCreateInput
  ) => UserRefreshTokenPromise;
  updateUserRefreshToken: (
    args: {
      data: UserRefreshTokenUpdateInput;
      where: UserRefreshTokenWhereUniqueInput;
    }
  ) => UserRefreshTokenPromise;
  updateManyUserRefreshTokens: (
    args: {
      data: UserRefreshTokenUpdateManyMutationInput;
      where?: UserRefreshTokenWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserRefreshToken: (
    args: {
      where: UserRefreshTokenWhereUniqueInput;
      create: UserRefreshTokenCreateInput;
      update: UserRefreshTokenUpdateInput;
    }
  ) => UserRefreshTokenPromise;
  deleteUserRefreshToken: (
    where: UserRefreshTokenWhereUniqueInput
  ) => UserRefreshTokenPromise;
  deleteManyUserRefreshTokens: (
    where?: UserRefreshTokenWhereInput
  ) => BatchPayloadPromise;
  createVerificationCode: (
    data: VerificationCodeCreateInput
  ) => VerificationCodePromise;
  updateVerificationCode: (
    args: {
      data: VerificationCodeUpdateInput;
      where: VerificationCodeWhereUniqueInput;
    }
  ) => VerificationCodePromise;
  updateManyVerificationCodes: (
    args: {
      data: VerificationCodeUpdateManyMutationInput;
      where?: VerificationCodeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertVerificationCode: (
    args: {
      where: VerificationCodeWhereUniqueInput;
      create: VerificationCodeCreateInput;
      update: VerificationCodeUpdateInput;
    }
  ) => VerificationCodePromise;
  deleteVerificationCode: (
    where: VerificationCodeWhereUniqueInput
  ) => VerificationCodePromise;
  deleteManyVerificationCodes: (
    where?: VerificationCodeWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  logError: (
    where?: LogErrorSubscriptionWhereInput
  ) => LogErrorSubscriptionPayloadSubscription;
  logSession: (
    where?: LogSessionSubscriptionWhereInput
  ) => LogSessionSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userRefreshToken: (
    where?: UserRefreshTokenSubscriptionWhereInput
  ) => UserRefreshTokenSubscriptionPayloadSubscription;
  verificationCode: (
    where?: VerificationCodeSubscriptionWhereInput
  ) => VerificationCodeSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type LogErrorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "args_ASC"
  | "args_DESC"
  | "resolver_ASC"
  | "resolver_DESC"
  | "errorMsg_ASC"
  | "errorMsg_DESC"
  | "errorType_ASC"
  | "errorType_DESC"
  | "errorCode_ASC"
  | "errorCode_DESC"
  | "errorArgs_ASC"
  | "errorArgs_DESC";

export type LogSessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "args_ASC"
  | "args_DESC"
  | "ipAddress_ASC"
  | "ipAddress_DESC"
  | "origin_ASC"
  | "origin_DESC"
  | "resolver_ASC"
  | "resolver_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "password_ASC"
  | "password_DESC"
  | "salt_ASC"
  | "salt_DESC"
  | "userName_ASC"
  | "userName_DESC"
  | "nickName_ASC"
  | "nickName_DESC"
  | "childName_ASC"
  | "childName_DESC"
  | "openId_ASC"
  | "openId_DESC"
  | "unionId_ASC"
  | "unionId_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "country_ASC"
  | "country_DESC"
  | "province_ASC"
  | "province_DESC"
  | "city_ASC"
  | "city_DESC"
  | "language_ASC"
  | "language_DESC"
  | "sessionKey_ASC"
  | "sessionKey_DESC"
  | "remark_ASC"
  | "remark_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "forbiddenAt_ASC"
  | "forbiddenAt_DESC"
  | "userStatus_ASC"
  | "userStatus_DESC"
  | "userRole_ASC"
  | "userRole_DESC"
  | "isChildAccount_ASC"
  | "isChildAccount_DESC"
  | "childAccountForbiddenAt_ASC"
  | "childAccountForbiddenAt_DESC"
  | "childAccountForbidden_ASC"
  | "childAccountForbidden_DESC"
  | "childAccountDeletedAt_ASC"
  | "childAccountDeletedAt_DESC"
  | "childAccountDeleted_ASC"
  | "childAccountDeleted_DESC"
  | "allowEdit_ASC"
  | "allowEdit_DESC"
  | "expiredAt_ASC"
  | "expiredAt_DESC";

export type UserRefreshTokenOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "expiredAt_ASC"
  | "expiredAt_DESC"
  | "refreshToken_ASC"
  | "refreshToken_DESC";

export type VerificationCodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "expiredAt_ASC"
  | "expiredAt_DESC"
  | "code_ASC"
  | "code_DESC"
  | "codeType_ASC"
  | "codeType_DESC"
  | "phone_ASC"
  | "phone_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface LogErrorUpdateOneWithoutLogSessionInput {
  create?: LogErrorCreateWithoutLogSessionInput;
  update?: LogErrorUpdateWithoutLogSessionDataInput;
  upsert?: LogErrorUpsertWithoutLogSessionInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LogErrorWhereUniqueInput;
}

export type LogErrorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserCreateInput {
  phone?: String;
  password?: String;
  salt?: String;
  userName?: String;
  nickName?: String;
  childName?: String;
  openId?: String;
  unionId?: String;
  birthday?: DateTimeInput;
  avatar?: String;
  country?: String;
  province?: String;
  city?: String;
  language?: String;
  sessionKey?: String;
  remark?: String;
  gender?: Int;
  deletedAt?: DateTimeInput;
  forbiddenAt?: DateTimeInput;
  userStatus?: Int;
  userRole?: Int;
  isChildAccount?: Boolean;
  childAccountForbiddenAt?: DateTimeInput;
  childAccountForbidden?: Boolean;
  childAccountDeletedAt?: DateTimeInput;
  childAccountDeleted?: Boolean;
  allowEdit?: Boolean;
  expiredAt?: DateTimeInput;
  childAccounts?: UserCreateManyWithoutParentAccountInput;
  parentAccount?: UserCreateOneWithoutChildAccountsInput;
  refreshTokens?: UserRefreshTokenCreateManyWithoutOwnerInput;
}

export interface LogErrorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  resolver?: String;
  resolver_not?: String;
  resolver_in?: String[] | String;
  resolver_not_in?: String[] | String;
  resolver_lt?: String;
  resolver_lte?: String;
  resolver_gt?: String;
  resolver_gte?: String;
  resolver_contains?: String;
  resolver_not_contains?: String;
  resolver_starts_with?: String;
  resolver_not_starts_with?: String;
  resolver_ends_with?: String;
  resolver_not_ends_with?: String;
  errorMsg?: String;
  errorMsg_not?: String;
  errorMsg_in?: String[] | String;
  errorMsg_not_in?: String[] | String;
  errorMsg_lt?: String;
  errorMsg_lte?: String;
  errorMsg_gt?: String;
  errorMsg_gte?: String;
  errorMsg_contains?: String;
  errorMsg_not_contains?: String;
  errorMsg_starts_with?: String;
  errorMsg_not_starts_with?: String;
  errorMsg_ends_with?: String;
  errorMsg_not_ends_with?: String;
  errorType?: String;
  errorType_not?: String;
  errorType_in?: String[] | String;
  errorType_not_in?: String[] | String;
  errorType_lt?: String;
  errorType_lte?: String;
  errorType_gt?: String;
  errorType_gte?: String;
  errorType_contains?: String;
  errorType_not_contains?: String;
  errorType_starts_with?: String;
  errorType_not_starts_with?: String;
  errorType_ends_with?: String;
  errorType_not_ends_with?: String;
  errorCode?: Int;
  errorCode_not?: Int;
  errorCode_in?: Int[] | Int;
  errorCode_not_in?: Int[] | Int;
  errorCode_lt?: Int;
  errorCode_lte?: Int;
  errorCode_gt?: Int;
  errorCode_gte?: Int;
  logSession?: LogSessionWhereInput;
  AND?: LogErrorWhereInput[] | LogErrorWhereInput;
  OR?: LogErrorWhereInput[] | LogErrorWhereInput;
  NOT?: LogErrorWhereInput[] | LogErrorWhereInput;
}

export interface LogErrorCreateInput {
  args?: Json;
  resolver?: String;
  errorMsg?: String;
  errorType?: String;
  errorCode?: Int;
  errorArgs?: Json;
  logSession?: LogSessionCreateOneWithoutLogErrorInput;
}

export interface UserRefreshTokenUpsertWithWhereUniqueWithoutOwnerInput {
  where: UserRefreshTokenWhereUniqueInput;
  update: UserRefreshTokenUpdateWithoutOwnerDataInput;
  create: UserRefreshTokenCreateWithoutOwnerInput;
}

export interface LogSessionCreateOneWithoutLogErrorInput {
  create?: LogSessionCreateWithoutLogErrorInput;
  connect?: LogSessionWhereUniqueInput;
}

export interface UserCreateManyWithoutParentAccountInput {
  create?:
    | UserCreateWithoutParentAccountInput[]
    | UserCreateWithoutParentAccountInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface LogSessionCreateWithoutLogErrorInput {
  args?: Json;
  ipAddress?: String;
  origin: String;
  resolver: String;
}

export interface UserRefreshTokenSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserRefreshTokenWhereInput;
  AND?:
    | UserRefreshTokenSubscriptionWhereInput[]
    | UserRefreshTokenSubscriptionWhereInput;
  OR?:
    | UserRefreshTokenSubscriptionWhereInput[]
    | UserRefreshTokenSubscriptionWhereInput;
  NOT?:
    | UserRefreshTokenSubscriptionWhereInput[]
    | UserRefreshTokenSubscriptionWhereInput;
}

export interface LogErrorUpdateInput {
  args?: Json;
  resolver?: String;
  errorMsg?: String;
  errorType?: String;
  errorCode?: Int;
  errorArgs?: Json;
  logSession?: LogSessionUpdateOneWithoutLogErrorInput;
}

export interface LogSessionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LogSessionWhereInput;
  AND?: LogSessionSubscriptionWhereInput[] | LogSessionSubscriptionWhereInput;
  OR?: LogSessionSubscriptionWhereInput[] | LogSessionSubscriptionWhereInput;
  NOT?: LogSessionSubscriptionWhereInput[] | LogSessionSubscriptionWhereInput;
}

export interface LogSessionUpdateOneWithoutLogErrorInput {
  create?: LogSessionCreateWithoutLogErrorInput;
  update?: LogSessionUpdateWithoutLogErrorDataInput;
  upsert?: LogSessionUpsertWithoutLogErrorInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LogSessionWhereUniqueInput;
}

export interface LogErrorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LogErrorWhereInput;
  AND?: LogErrorSubscriptionWhereInput[] | LogErrorSubscriptionWhereInput;
  OR?: LogErrorSubscriptionWhereInput[] | LogErrorSubscriptionWhereInput;
  NOT?: LogErrorSubscriptionWhereInput[] | LogErrorSubscriptionWhereInput;
}

export interface LogSessionUpdateWithoutLogErrorDataInput {
  args?: Json;
  ipAddress?: String;
  origin?: String;
  resolver?: String;
}

export interface VerificationCodeUpdateInput {
  expiredAt?: DateTimeInput;
  code?: String;
  codeType?: Int;
  phone?: String;
}

export interface LogSessionUpsertWithoutLogErrorInput {
  update: LogSessionUpdateWithoutLogErrorDataInput;
  create: LogSessionCreateWithoutLogErrorInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface LogErrorUpdateManyMutationInput {
  args?: Json;
  resolver?: String;
  errorMsg?: String;
  errorType?: String;
  errorCode?: Int;
  errorArgs?: Json;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  salt?: String;
  salt_not?: String;
  salt_in?: String[] | String;
  salt_not_in?: String[] | String;
  salt_lt?: String;
  salt_lte?: String;
  salt_gt?: String;
  salt_gte?: String;
  salt_contains?: String;
  salt_not_contains?: String;
  salt_starts_with?: String;
  salt_not_starts_with?: String;
  salt_ends_with?: String;
  salt_not_ends_with?: String;
  userName?: String;
  userName_not?: String;
  userName_in?: String[] | String;
  userName_not_in?: String[] | String;
  userName_lt?: String;
  userName_lte?: String;
  userName_gt?: String;
  userName_gte?: String;
  userName_contains?: String;
  userName_not_contains?: String;
  userName_starts_with?: String;
  userName_not_starts_with?: String;
  userName_ends_with?: String;
  userName_not_ends_with?: String;
  nickName?: String;
  nickName_not?: String;
  nickName_in?: String[] | String;
  nickName_not_in?: String[] | String;
  nickName_lt?: String;
  nickName_lte?: String;
  nickName_gt?: String;
  nickName_gte?: String;
  nickName_contains?: String;
  nickName_not_contains?: String;
  nickName_starts_with?: String;
  nickName_not_starts_with?: String;
  nickName_ends_with?: String;
  nickName_not_ends_with?: String;
  childName?: String;
  childName_not?: String;
  childName_in?: String[] | String;
  childName_not_in?: String[] | String;
  childName_lt?: String;
  childName_lte?: String;
  childName_gt?: String;
  childName_gte?: String;
  childName_contains?: String;
  childName_not_contains?: String;
  childName_starts_with?: String;
  childName_not_starts_with?: String;
  childName_ends_with?: String;
  childName_not_ends_with?: String;
  openId?: String;
  openId_not?: String;
  openId_in?: String[] | String;
  openId_not_in?: String[] | String;
  openId_lt?: String;
  openId_lte?: String;
  openId_gt?: String;
  openId_gte?: String;
  openId_contains?: String;
  openId_not_contains?: String;
  openId_starts_with?: String;
  openId_not_starts_with?: String;
  openId_ends_with?: String;
  openId_not_ends_with?: String;
  unionId?: String;
  unionId_not?: String;
  unionId_in?: String[] | String;
  unionId_not_in?: String[] | String;
  unionId_lt?: String;
  unionId_lte?: String;
  unionId_gt?: String;
  unionId_gte?: String;
  unionId_contains?: String;
  unionId_not_contains?: String;
  unionId_starts_with?: String;
  unionId_not_starts_with?: String;
  unionId_ends_with?: String;
  unionId_not_ends_with?: String;
  birthday?: DateTimeInput;
  birthday_not?: DateTimeInput;
  birthday_in?: DateTimeInput[] | DateTimeInput;
  birthday_not_in?: DateTimeInput[] | DateTimeInput;
  birthday_lt?: DateTimeInput;
  birthday_lte?: DateTimeInput;
  birthday_gt?: DateTimeInput;
  birthday_gte?: DateTimeInput;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  province?: String;
  province_not?: String;
  province_in?: String[] | String;
  province_not_in?: String[] | String;
  province_lt?: String;
  province_lte?: String;
  province_gt?: String;
  province_gte?: String;
  province_contains?: String;
  province_not_contains?: String;
  province_starts_with?: String;
  province_not_starts_with?: String;
  province_ends_with?: String;
  province_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  language?: String;
  language_not?: String;
  language_in?: String[] | String;
  language_not_in?: String[] | String;
  language_lt?: String;
  language_lte?: String;
  language_gt?: String;
  language_gte?: String;
  language_contains?: String;
  language_not_contains?: String;
  language_starts_with?: String;
  language_not_starts_with?: String;
  language_ends_with?: String;
  language_not_ends_with?: String;
  sessionKey?: String;
  sessionKey_not?: String;
  sessionKey_in?: String[] | String;
  sessionKey_not_in?: String[] | String;
  sessionKey_lt?: String;
  sessionKey_lte?: String;
  sessionKey_gt?: String;
  sessionKey_gte?: String;
  sessionKey_contains?: String;
  sessionKey_not_contains?: String;
  sessionKey_starts_with?: String;
  sessionKey_not_starts_with?: String;
  sessionKey_ends_with?: String;
  sessionKey_not_ends_with?: String;
  remark?: String;
  remark_not?: String;
  remark_in?: String[] | String;
  remark_not_in?: String[] | String;
  remark_lt?: String;
  remark_lte?: String;
  remark_gt?: String;
  remark_gte?: String;
  remark_contains?: String;
  remark_not_contains?: String;
  remark_starts_with?: String;
  remark_not_starts_with?: String;
  remark_ends_with?: String;
  remark_not_ends_with?: String;
  gender?: Int;
  gender_not?: Int;
  gender_in?: Int[] | Int;
  gender_not_in?: Int[] | Int;
  gender_lt?: Int;
  gender_lte?: Int;
  gender_gt?: Int;
  gender_gte?: Int;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  forbiddenAt?: DateTimeInput;
  forbiddenAt_not?: DateTimeInput;
  forbiddenAt_in?: DateTimeInput[] | DateTimeInput;
  forbiddenAt_not_in?: DateTimeInput[] | DateTimeInput;
  forbiddenAt_lt?: DateTimeInput;
  forbiddenAt_lte?: DateTimeInput;
  forbiddenAt_gt?: DateTimeInput;
  forbiddenAt_gte?: DateTimeInput;
  userStatus?: Int;
  userStatus_not?: Int;
  userStatus_in?: Int[] | Int;
  userStatus_not_in?: Int[] | Int;
  userStatus_lt?: Int;
  userStatus_lte?: Int;
  userStatus_gt?: Int;
  userStatus_gte?: Int;
  userRole?: Int;
  userRole_not?: Int;
  userRole_in?: Int[] | Int;
  userRole_not_in?: Int[] | Int;
  userRole_lt?: Int;
  userRole_lte?: Int;
  userRole_gt?: Int;
  userRole_gte?: Int;
  isChildAccount?: Boolean;
  isChildAccount_not?: Boolean;
  childAccountForbiddenAt?: DateTimeInput;
  childAccountForbiddenAt_not?: DateTimeInput;
  childAccountForbiddenAt_in?: DateTimeInput[] | DateTimeInput;
  childAccountForbiddenAt_not_in?: DateTimeInput[] | DateTimeInput;
  childAccountForbiddenAt_lt?: DateTimeInput;
  childAccountForbiddenAt_lte?: DateTimeInput;
  childAccountForbiddenAt_gt?: DateTimeInput;
  childAccountForbiddenAt_gte?: DateTimeInput;
  childAccountForbidden?: Boolean;
  childAccountForbidden_not?: Boolean;
  childAccountDeletedAt?: DateTimeInput;
  childAccountDeletedAt_not?: DateTimeInput;
  childAccountDeletedAt_in?: DateTimeInput[] | DateTimeInput;
  childAccountDeletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  childAccountDeletedAt_lt?: DateTimeInput;
  childAccountDeletedAt_lte?: DateTimeInput;
  childAccountDeletedAt_gt?: DateTimeInput;
  childAccountDeletedAt_gte?: DateTimeInput;
  childAccountDeleted?: Boolean;
  childAccountDeleted_not?: Boolean;
  allowEdit?: Boolean;
  allowEdit_not?: Boolean;
  expiredAt?: DateTimeInput;
  expiredAt_not?: DateTimeInput;
  expiredAt_in?: DateTimeInput[] | DateTimeInput;
  expiredAt_not_in?: DateTimeInput[] | DateTimeInput;
  expiredAt_lt?: DateTimeInput;
  expiredAt_lte?: DateTimeInput;
  expiredAt_gt?: DateTimeInput;
  expiredAt_gte?: DateTimeInput;
  childAccounts_every?: UserWhereInput;
  childAccounts_some?: UserWhereInput;
  childAccounts_none?: UserWhereInput;
  parentAccount?: UserWhereInput;
  refreshTokens_every?: UserRefreshTokenWhereInput;
  refreshTokens_some?: UserRefreshTokenWhereInput;
  refreshTokens_none?: UserRefreshTokenWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface UserUpsertWithWhereUniqueWithoutParentAccountInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutParentAccountDataInput;
  create: UserCreateWithoutParentAccountInput;
}

export interface UserUpsertWithoutRefreshTokensInput {
  update: UserUpdateWithoutRefreshTokensDataInput;
  create: UserCreateWithoutRefreshTokensInput;
}

export interface UserRefreshTokenUpdateManyDataInput {
  expiredAt?: DateTimeInput;
  refreshToken?: String;
}

export interface UserUpdateOneRequiredWithoutRefreshTokensInput {
  create?: UserCreateWithoutRefreshTokensInput;
  update?: UserUpdateWithoutRefreshTokensDataInput;
  upsert?: UserUpsertWithoutRefreshTokensInput;
  connect?: UserWhereUniqueInput;
}

export interface LogSessionCreateInput {
  args?: Json;
  ipAddress?: String;
  logError?: LogErrorCreateOneWithoutLogSessionInput;
  origin: String;
  resolver: String;
}

export interface UserCreateWithoutRefreshTokensInput {
  phone?: String;
  password?: String;
  salt?: String;
  userName?: String;
  nickName?: String;
  childName?: String;
  openId?: String;
  unionId?: String;
  birthday?: DateTimeInput;
  avatar?: String;
  country?: String;
  province?: String;
  city?: String;
  language?: String;
  sessionKey?: String;
  remark?: String;
  gender?: Int;
  deletedAt?: DateTimeInput;
  forbiddenAt?: DateTimeInput;
  userStatus?: Int;
  userRole?: Int;
  isChildAccount?: Boolean;
  childAccountForbiddenAt?: DateTimeInput;
  childAccountForbidden?: Boolean;
  childAccountDeletedAt?: DateTimeInput;
  childAccountDeleted?: Boolean;
  allowEdit?: Boolean;
  expiredAt?: DateTimeInput;
  childAccounts?: UserCreateManyWithoutParentAccountInput;
  parentAccount?: UserCreateOneWithoutChildAccountsInput;
}

export interface LogErrorCreateOneWithoutLogSessionInput {
  create?: LogErrorCreateWithoutLogSessionInput;
  connect?: LogErrorWhereUniqueInput;
}

export type UserRefreshTokenWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  refreshToken?: String;
}>;

export interface LogErrorCreateWithoutLogSessionInput {
  args?: Json;
  resolver?: String;
  errorMsg?: String;
  errorType?: String;
  errorCode?: Int;
  errorArgs?: Json;
}

export interface UserUpdateManyMutationInput {
  phone?: String;
  password?: String;
  salt?: String;
  userName?: String;
  nickName?: String;
  childName?: String;
  openId?: String;
  unionId?: String;
  birthday?: DateTimeInput;
  avatar?: String;
  country?: String;
  province?: String;
  city?: String;
  language?: String;
  sessionKey?: String;
  remark?: String;
  gender?: Int;
  deletedAt?: DateTimeInput;
  forbiddenAt?: DateTimeInput;
  userStatus?: Int;
  userRole?: Int;
  isChildAccount?: Boolean;
  childAccountForbiddenAt?: DateTimeInput;
  childAccountForbidden?: Boolean;
  childAccountDeletedAt?: DateTimeInput;
  childAccountDeleted?: Boolean;
  allowEdit?: Boolean;
  expiredAt?: DateTimeInput;
}

export interface LogSessionUpdateInput {
  args?: Json;
  ipAddress?: String;
  logError?: LogErrorUpdateOneWithoutLogSessionInput;
  origin?: String;
  resolver?: String;
}

export type VerificationCodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserRefreshTokenUpdateManyWithWhereNestedInput {
  where: UserRefreshTokenScalarWhereInput;
  data: UserRefreshTokenUpdateManyDataInput;
}

export interface VerificationCodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  expiredAt?: DateTimeInput;
  expiredAt_not?: DateTimeInput;
  expiredAt_in?: DateTimeInput[] | DateTimeInput;
  expiredAt_not_in?: DateTimeInput[] | DateTimeInput;
  expiredAt_lt?: DateTimeInput;
  expiredAt_lte?: DateTimeInput;
  expiredAt_gt?: DateTimeInput;
  expiredAt_gte?: DateTimeInput;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  codeType?: Int;
  codeType_not?: Int;
  codeType_in?: Int[] | Int;
  codeType_not_in?: Int[] | Int;
  codeType_lt?: Int;
  codeType_lte?: Int;
  codeType_gt?: Int;
  codeType_gte?: Int;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  AND?: VerificationCodeWhereInput[] | VerificationCodeWhereInput;
  OR?: VerificationCodeWhereInput[] | VerificationCodeWhereInput;
  NOT?: VerificationCodeWhereInput[] | VerificationCodeWhereInput;
}

export interface LogErrorUpdateWithoutLogSessionDataInput {
  args?: Json;
  resolver?: String;
  errorMsg?: String;
  errorType?: String;
  errorCode?: Int;
  errorArgs?: Json;
}

export interface UserUpdateManyDataInput {
  phone?: String;
  password?: String;
  salt?: String;
  userName?: String;
  nickName?: String;
  childName?: String;
  openId?: String;
  unionId?: String;
  birthday?: DateTimeInput;
  avatar?: String;
  country?: String;
  province?: String;
  city?: String;
  language?: String;
  sessionKey?: String;
  remark?: String;
  gender?: Int;
  deletedAt?: DateTimeInput;
  forbiddenAt?: DateTimeInput;
  userStatus?: Int;
  userRole?: Int;
  isChildAccount?: Boolean;
  childAccountForbiddenAt?: DateTimeInput;
  childAccountForbidden?: Boolean;
  childAccountDeletedAt?: DateTimeInput;
  childAccountDeleted?: Boolean;
  allowEdit?: Boolean;
  expiredAt?: DateTimeInput;
}

export interface LogErrorUpsertWithoutLogSessionInput {
  update: LogErrorUpdateWithoutLogSessionDataInput;
  create: LogErrorCreateWithoutLogSessionInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  salt?: String;
  salt_not?: String;
  salt_in?: String[] | String;
  salt_not_in?: String[] | String;
  salt_lt?: String;
  salt_lte?: String;
  salt_gt?: String;
  salt_gte?: String;
  salt_contains?: String;
  salt_not_contains?: String;
  salt_starts_with?: String;
  salt_not_starts_with?: String;
  salt_ends_with?: String;
  salt_not_ends_with?: String;
  userName?: String;
  userName_not?: String;
  userName_in?: String[] | String;
  userName_not_in?: String[] | String;
  userName_lt?: String;
  userName_lte?: String;
  userName_gt?: String;
  userName_gte?: String;
  userName_contains?: String;
  userName_not_contains?: String;
  userName_starts_with?: String;
  userName_not_starts_with?: String;
  userName_ends_with?: String;
  userName_not_ends_with?: String;
  nickName?: String;
  nickName_not?: String;
  nickName_in?: String[] | String;
  nickName_not_in?: String[] | String;
  nickName_lt?: String;
  nickName_lte?: String;
  nickName_gt?: String;
  nickName_gte?: String;
  nickName_contains?: String;
  nickName_not_contains?: String;
  nickName_starts_with?: String;
  nickName_not_starts_with?: String;
  nickName_ends_with?: String;
  nickName_not_ends_with?: String;
  childName?: String;
  childName_not?: String;
  childName_in?: String[] | String;
  childName_not_in?: String[] | String;
  childName_lt?: String;
  childName_lte?: String;
  childName_gt?: String;
  childName_gte?: String;
  childName_contains?: String;
  childName_not_contains?: String;
  childName_starts_with?: String;
  childName_not_starts_with?: String;
  childName_ends_with?: String;
  childName_not_ends_with?: String;
  openId?: String;
  openId_not?: String;
  openId_in?: String[] | String;
  openId_not_in?: String[] | String;
  openId_lt?: String;
  openId_lte?: String;
  openId_gt?: String;
  openId_gte?: String;
  openId_contains?: String;
  openId_not_contains?: String;
  openId_starts_with?: String;
  openId_not_starts_with?: String;
  openId_ends_with?: String;
  openId_not_ends_with?: String;
  unionId?: String;
  unionId_not?: String;
  unionId_in?: String[] | String;
  unionId_not_in?: String[] | String;
  unionId_lt?: String;
  unionId_lte?: String;
  unionId_gt?: String;
  unionId_gte?: String;
  unionId_contains?: String;
  unionId_not_contains?: String;
  unionId_starts_with?: String;
  unionId_not_starts_with?: String;
  unionId_ends_with?: String;
  unionId_not_ends_with?: String;
  birthday?: DateTimeInput;
  birthday_not?: DateTimeInput;
  birthday_in?: DateTimeInput[] | DateTimeInput;
  birthday_not_in?: DateTimeInput[] | DateTimeInput;
  birthday_lt?: DateTimeInput;
  birthday_lte?: DateTimeInput;
  birthday_gt?: DateTimeInput;
  birthday_gte?: DateTimeInput;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  province?: String;
  province_not?: String;
  province_in?: String[] | String;
  province_not_in?: String[] | String;
  province_lt?: String;
  province_lte?: String;
  province_gt?: String;
  province_gte?: String;
  province_contains?: String;
  province_not_contains?: String;
  province_starts_with?: String;
  province_not_starts_with?: String;
  province_ends_with?: String;
  province_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  language?: String;
  language_not?: String;
  language_in?: String[] | String;
  language_not_in?: String[] | String;
  language_lt?: String;
  language_lte?: String;
  language_gt?: String;
  language_gte?: String;
  language_contains?: String;
  language_not_contains?: String;
  language_starts_with?: String;
  language_not_starts_with?: String;
  language_ends_with?: String;
  language_not_ends_with?: String;
  sessionKey?: String;
  sessionKey_not?: String;
  sessionKey_in?: String[] | String;
  sessionKey_not_in?: String[] | String;
  sessionKey_lt?: String;
  sessionKey_lte?: String;
  sessionKey_gt?: String;
  sessionKey_gte?: String;
  sessionKey_contains?: String;
  sessionKey_not_contains?: String;
  sessionKey_starts_with?: String;
  sessionKey_not_starts_with?: String;
  sessionKey_ends_with?: String;
  sessionKey_not_ends_with?: String;
  remark?: String;
  remark_not?: String;
  remark_in?: String[] | String;
  remark_not_in?: String[] | String;
  remark_lt?: String;
  remark_lte?: String;
  remark_gt?: String;
  remark_gte?: String;
  remark_contains?: String;
  remark_not_contains?: String;
  remark_starts_with?: String;
  remark_not_starts_with?: String;
  remark_ends_with?: String;
  remark_not_ends_with?: String;
  gender?: Int;
  gender_not?: Int;
  gender_in?: Int[] | Int;
  gender_not_in?: Int[] | Int;
  gender_lt?: Int;
  gender_lte?: Int;
  gender_gt?: Int;
  gender_gte?: Int;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  forbiddenAt?: DateTimeInput;
  forbiddenAt_not?: DateTimeInput;
  forbiddenAt_in?: DateTimeInput[] | DateTimeInput;
  forbiddenAt_not_in?: DateTimeInput[] | DateTimeInput;
  forbiddenAt_lt?: DateTimeInput;
  forbiddenAt_lte?: DateTimeInput;
  forbiddenAt_gt?: DateTimeInput;
  forbiddenAt_gte?: DateTimeInput;
  userStatus?: Int;
  userStatus_not?: Int;
  userStatus_in?: Int[] | Int;
  userStatus_not_in?: Int[] | Int;
  userStatus_lt?: Int;
  userStatus_lte?: Int;
  userStatus_gt?: Int;
  userStatus_gte?: Int;
  userRole?: Int;
  userRole_not?: Int;
  userRole_in?: Int[] | Int;
  userRole_not_in?: Int[] | Int;
  userRole_lt?: Int;
  userRole_lte?: Int;
  userRole_gt?: Int;
  userRole_gte?: Int;
  isChildAccount?: Boolean;
  isChildAccount_not?: Boolean;
  childAccountForbiddenAt?: DateTimeInput;
  childAccountForbiddenAt_not?: DateTimeInput;
  childAccountForbiddenAt_in?: DateTimeInput[] | DateTimeInput;
  childAccountForbiddenAt_not_in?: DateTimeInput[] | DateTimeInput;
  childAccountForbiddenAt_lt?: DateTimeInput;
  childAccountForbiddenAt_lte?: DateTimeInput;
  childAccountForbiddenAt_gt?: DateTimeInput;
  childAccountForbiddenAt_gte?: DateTimeInput;
  childAccountForbidden?: Boolean;
  childAccountForbidden_not?: Boolean;
  childAccountDeletedAt?: DateTimeInput;
  childAccountDeletedAt_not?: DateTimeInput;
  childAccountDeletedAt_in?: DateTimeInput[] | DateTimeInput;
  childAccountDeletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  childAccountDeletedAt_lt?: DateTimeInput;
  childAccountDeletedAt_lte?: DateTimeInput;
  childAccountDeletedAt_gt?: DateTimeInput;
  childAccountDeletedAt_gte?: DateTimeInput;
  childAccountDeleted?: Boolean;
  childAccountDeleted_not?: Boolean;
  allowEdit?: Boolean;
  allowEdit_not?: Boolean;
  expiredAt?: DateTimeInput;
  expiredAt_not?: DateTimeInput;
  expiredAt_in?: DateTimeInput[] | DateTimeInput;
  expiredAt_not_in?: DateTimeInput[] | DateTimeInput;
  expiredAt_lt?: DateTimeInput;
  expiredAt_lte?: DateTimeInput;
  expiredAt_gt?: DateTimeInput;
  expiredAt_gte?: DateTimeInput;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface LogSessionUpdateManyMutationInput {
  args?: Json;
  ipAddress?: String;
  origin?: String;
  resolver?: String;
}

export interface VerificationCodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VerificationCodeWhereInput;
  AND?:
    | VerificationCodeSubscriptionWhereInput[]
    | VerificationCodeSubscriptionWhereInput;
  OR?:
    | VerificationCodeSubscriptionWhereInput[]
    | VerificationCodeSubscriptionWhereInput;
  NOT?:
    | VerificationCodeSubscriptionWhereInput[]
    | VerificationCodeSubscriptionWhereInput;
}

export interface LogSessionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  ipAddress?: String;
  ipAddress_not?: String;
  ipAddress_in?: String[] | String;
  ipAddress_not_in?: String[] | String;
  ipAddress_lt?: String;
  ipAddress_lte?: String;
  ipAddress_gt?: String;
  ipAddress_gte?: String;
  ipAddress_contains?: String;
  ipAddress_not_contains?: String;
  ipAddress_starts_with?: String;
  ipAddress_not_starts_with?: String;
  ipAddress_ends_with?: String;
  ipAddress_not_ends_with?: String;
  logError?: LogErrorWhereInput;
  origin?: String;
  origin_not?: String;
  origin_in?: String[] | String;
  origin_not_in?: String[] | String;
  origin_lt?: String;
  origin_lte?: String;
  origin_gt?: String;
  origin_gte?: String;
  origin_contains?: String;
  origin_not_contains?: String;
  origin_starts_with?: String;
  origin_not_starts_with?: String;
  origin_ends_with?: String;
  origin_not_ends_with?: String;
  resolver?: String;
  resolver_not?: String;
  resolver_in?: String[] | String;
  resolver_not_in?: String[] | String;
  resolver_lt?: String;
  resolver_lte?: String;
  resolver_gt?: String;
  resolver_gte?: String;
  resolver_contains?: String;
  resolver_not_contains?: String;
  resolver_starts_with?: String;
  resolver_not_starts_with?: String;
  resolver_ends_with?: String;
  resolver_not_ends_with?: String;
  AND?: LogSessionWhereInput[] | LogSessionWhereInput;
  OR?: LogSessionWhereInput[] | LogSessionWhereInput;
  NOT?: LogSessionWhereInput[] | LogSessionWhereInput;
}

export type LogSessionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserRefreshTokenScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  expiredAt?: DateTimeInput;
  expiredAt_not?: DateTimeInput;
  expiredAt_in?: DateTimeInput[] | DateTimeInput;
  expiredAt_not_in?: DateTimeInput[] | DateTimeInput;
  expiredAt_lt?: DateTimeInput;
  expiredAt_lte?: DateTimeInput;
  expiredAt_gt?: DateTimeInput;
  expiredAt_gte?: DateTimeInput;
  refreshToken?: String;
  refreshToken_not?: String;
  refreshToken_in?: String[] | String;
  refreshToken_not_in?: String[] | String;
  refreshToken_lt?: String;
  refreshToken_lte?: String;
  refreshToken_gt?: String;
  refreshToken_gte?: String;
  refreshToken_contains?: String;
  refreshToken_not_contains?: String;
  refreshToken_starts_with?: String;
  refreshToken_not_starts_with?: String;
  refreshToken_ends_with?: String;
  refreshToken_not_ends_with?: String;
  AND?: UserRefreshTokenScalarWhereInput[] | UserRefreshTokenScalarWhereInput;
  OR?: UserRefreshTokenScalarWhereInput[] | UserRefreshTokenScalarWhereInput;
  NOT?: UserRefreshTokenScalarWhereInput[] | UserRefreshTokenScalarWhereInput;
}

export interface VerificationCodeCreateInput {
  expiredAt: DateTimeInput;
  code: String;
  codeType?: Int;
  phone: String;
}

export interface UserCreateWithoutParentAccountInput {
  phone?: String;
  password?: String;
  salt?: String;
  userName?: String;
  nickName?: String;
  childName?: String;
  openId?: String;
  unionId?: String;
  birthday?: DateTimeInput;
  avatar?: String;
  country?: String;
  province?: String;
  city?: String;
  language?: String;
  sessionKey?: String;
  remark?: String;
  gender?: Int;
  deletedAt?: DateTimeInput;
  forbiddenAt?: DateTimeInput;
  userStatus?: Int;
  userRole?: Int;
  isChildAccount?: Boolean;
  childAccountForbiddenAt?: DateTimeInput;
  childAccountForbidden?: Boolean;
  childAccountDeletedAt?: DateTimeInput;
  childAccountDeleted?: Boolean;
  allowEdit?: Boolean;
  expiredAt?: DateTimeInput;
  childAccounts?: UserCreateManyWithoutParentAccountInput;
  refreshTokens?: UserRefreshTokenCreateManyWithoutOwnerInput;
}

export interface UserRefreshTokenWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  expiredAt?: DateTimeInput;
  expiredAt_not?: DateTimeInput;
  expiredAt_in?: DateTimeInput[] | DateTimeInput;
  expiredAt_not_in?: DateTimeInput[] | DateTimeInput;
  expiredAt_lt?: DateTimeInput;
  expiredAt_lte?: DateTimeInput;
  expiredAt_gt?: DateTimeInput;
  expiredAt_gte?: DateTimeInput;
  refreshToken?: String;
  refreshToken_not?: String;
  refreshToken_in?: String[] | String;
  refreshToken_not_in?: String[] | String;
  refreshToken_lt?: String;
  refreshToken_lte?: String;
  refreshToken_gt?: String;
  refreshToken_gte?: String;
  refreshToken_contains?: String;
  refreshToken_not_contains?: String;
  refreshToken_starts_with?: String;
  refreshToken_not_starts_with?: String;
  refreshToken_ends_with?: String;
  refreshToken_not_ends_with?: String;
  owner?: UserWhereInput;
  AND?: UserRefreshTokenWhereInput[] | UserRefreshTokenWhereInput;
  OR?: UserRefreshTokenWhereInput[] | UserRefreshTokenWhereInput;
  NOT?: UserRefreshTokenWhereInput[] | UserRefreshTokenWhereInput;
}

export interface UserRefreshTokenCreateManyWithoutOwnerInput {
  create?:
    | UserRefreshTokenCreateWithoutOwnerInput[]
    | UserRefreshTokenCreateWithoutOwnerInput;
  connect?:
    | UserRefreshTokenWhereUniqueInput[]
    | UserRefreshTokenWhereUniqueInput;
}

export interface UserRefreshTokenUpdateInput {
  expiredAt?: DateTimeInput;
  refreshToken?: String;
  owner?: UserUpdateOneRequiredWithoutRefreshTokensInput;
}

export interface UserRefreshTokenCreateWithoutOwnerInput {
  expiredAt: DateTimeInput;
  refreshToken: String;
}

export interface UserRefreshTokenCreateInput {
  expiredAt: DateTimeInput;
  refreshToken: String;
  owner: UserCreateOneWithoutRefreshTokensInput;
}

export interface UserCreateOneWithoutChildAccountsInput {
  create?: UserCreateWithoutChildAccountsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutChildAccountsDataInput {
  phone?: String;
  password?: String;
  salt?: String;
  userName?: String;
  nickName?: String;
  childName?: String;
  openId?: String;
  unionId?: String;
  birthday?: DateTimeInput;
  avatar?: String;
  country?: String;
  province?: String;
  city?: String;
  language?: String;
  sessionKey?: String;
  remark?: String;
  gender?: Int;
  deletedAt?: DateTimeInput;
  forbiddenAt?: DateTimeInput;
  userStatus?: Int;
  userRole?: Int;
  isChildAccount?: Boolean;
  childAccountForbiddenAt?: DateTimeInput;
  childAccountForbidden?: Boolean;
  childAccountDeletedAt?: DateTimeInput;
  childAccountDeleted?: Boolean;
  allowEdit?: Boolean;
  expiredAt?: DateTimeInput;
  parentAccount?: UserUpdateOneWithoutChildAccountsInput;
  refreshTokens?: UserRefreshTokenUpdateManyWithoutOwnerInput;
}

export interface UserCreateWithoutChildAccountsInput {
  phone?: String;
  password?: String;
  salt?: String;
  userName?: String;
  nickName?: String;
  childName?: String;
  openId?: String;
  unionId?: String;
  birthday?: DateTimeInput;
  avatar?: String;
  country?: String;
  province?: String;
  city?: String;
  language?: String;
  sessionKey?: String;
  remark?: String;
  gender?: Int;
  deletedAt?: DateTimeInput;
  forbiddenAt?: DateTimeInput;
  userStatus?: Int;
  userRole?: Int;
  isChildAccount?: Boolean;
  childAccountForbiddenAt?: DateTimeInput;
  childAccountForbidden?: Boolean;
  childAccountDeletedAt?: DateTimeInput;
  childAccountDeleted?: Boolean;
  allowEdit?: Boolean;
  expiredAt?: DateTimeInput;
  parentAccount?: UserCreateOneWithoutChildAccountsInput;
  refreshTokens?: UserRefreshTokenCreateManyWithoutOwnerInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateInput {
  phone?: String;
  password?: String;
  salt?: String;
  userName?: String;
  nickName?: String;
  childName?: String;
  openId?: String;
  unionId?: String;
  birthday?: DateTimeInput;
  avatar?: String;
  country?: String;
  province?: String;
  city?: String;
  language?: String;
  sessionKey?: String;
  remark?: String;
  gender?: Int;
  deletedAt?: DateTimeInput;
  forbiddenAt?: DateTimeInput;
  userStatus?: Int;
  userRole?: Int;
  isChildAccount?: Boolean;
  childAccountForbiddenAt?: DateTimeInput;
  childAccountForbidden?: Boolean;
  childAccountDeletedAt?: DateTimeInput;
  childAccountDeleted?: Boolean;
  allowEdit?: Boolean;
  expiredAt?: DateTimeInput;
  childAccounts?: UserUpdateManyWithoutParentAccountInput;
  parentAccount?: UserUpdateOneWithoutChildAccountsInput;
  refreshTokens?: UserRefreshTokenUpdateManyWithoutOwnerInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface UserUpdateManyWithoutParentAccountInput {
  create?:
    | UserCreateWithoutParentAccountInput[]
    | UserCreateWithoutParentAccountInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutParentAccountInput[]
    | UserUpdateWithWhereUniqueWithoutParentAccountInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutParentAccountInput[]
    | UserUpsertWithWhereUniqueWithoutParentAccountInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserRefreshTokenUpdateManyMutationInput {
  expiredAt?: DateTimeInput;
  refreshToken?: String;
}

export interface UserUpdateWithWhereUniqueWithoutParentAccountInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutParentAccountDataInput;
}

export interface UserCreateOneWithoutRefreshTokensInput {
  create?: UserCreateWithoutRefreshTokensInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateOneWithoutChildAccountsInput {
  create?: UserCreateWithoutChildAccountsInput;
  update?: UserUpdateWithoutChildAccountsDataInput;
  upsert?: UserUpsertWithoutChildAccountsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserRefreshTokenUpdateWithoutOwnerDataInput {
  expiredAt?: DateTimeInput;
  refreshToken?: String;
}

export interface UserRefreshTokenUpdateWithWhereUniqueWithoutOwnerInput {
  where: UserRefreshTokenWhereUniqueInput;
  data: UserRefreshTokenUpdateWithoutOwnerDataInput;
}

export interface UserRefreshTokenUpdateManyWithoutOwnerInput {
  create?:
    | UserRefreshTokenCreateWithoutOwnerInput[]
    | UserRefreshTokenCreateWithoutOwnerInput;
  delete?:
    | UserRefreshTokenWhereUniqueInput[]
    | UserRefreshTokenWhereUniqueInput;
  connect?:
    | UserRefreshTokenWhereUniqueInput[]
    | UserRefreshTokenWhereUniqueInput;
  disconnect?:
    | UserRefreshTokenWhereUniqueInput[]
    | UserRefreshTokenWhereUniqueInput;
  update?:
    | UserRefreshTokenUpdateWithWhereUniqueWithoutOwnerInput[]
    | UserRefreshTokenUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | UserRefreshTokenUpsertWithWhereUniqueWithoutOwnerInput[]
    | UserRefreshTokenUpsertWithWhereUniqueWithoutOwnerInput;
  deleteMany?:
    | UserRefreshTokenScalarWhereInput[]
    | UserRefreshTokenScalarWhereInput;
  updateMany?:
    | UserRefreshTokenUpdateManyWithWhereNestedInput[]
    | UserRefreshTokenUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithoutParentAccountDataInput {
  phone?: String;
  password?: String;
  salt?: String;
  userName?: String;
  nickName?: String;
  childName?: String;
  openId?: String;
  unionId?: String;
  birthday?: DateTimeInput;
  avatar?: String;
  country?: String;
  province?: String;
  city?: String;
  language?: String;
  sessionKey?: String;
  remark?: String;
  gender?: Int;
  deletedAt?: DateTimeInput;
  forbiddenAt?: DateTimeInput;
  userStatus?: Int;
  userRole?: Int;
  isChildAccount?: Boolean;
  childAccountForbiddenAt?: DateTimeInput;
  childAccountForbidden?: Boolean;
  childAccountDeletedAt?: DateTimeInput;
  childAccountDeleted?: Boolean;
  allowEdit?: Boolean;
  expiredAt?: DateTimeInput;
  childAccounts?: UserUpdateManyWithoutParentAccountInput;
  refreshTokens?: UserRefreshTokenUpdateManyWithoutOwnerInput;
}

export interface UserUpsertWithoutChildAccountsInput {
  update: UserUpdateWithoutChildAccountsDataInput;
  create: UserCreateWithoutChildAccountsInput;
}

export interface UserUpdateWithoutRefreshTokensDataInput {
  phone?: String;
  password?: String;
  salt?: String;
  userName?: String;
  nickName?: String;
  childName?: String;
  openId?: String;
  unionId?: String;
  birthday?: DateTimeInput;
  avatar?: String;
  country?: String;
  province?: String;
  city?: String;
  language?: String;
  sessionKey?: String;
  remark?: String;
  gender?: Int;
  deletedAt?: DateTimeInput;
  forbiddenAt?: DateTimeInput;
  userStatus?: Int;
  userRole?: Int;
  isChildAccount?: Boolean;
  childAccountForbiddenAt?: DateTimeInput;
  childAccountForbidden?: Boolean;
  childAccountDeletedAt?: DateTimeInput;
  childAccountDeleted?: Boolean;
  allowEdit?: Boolean;
  expiredAt?: DateTimeInput;
  childAccounts?: UserUpdateManyWithoutParentAccountInput;
  parentAccount?: UserUpdateOneWithoutChildAccountsInput;
}

export interface VerificationCodeUpdateManyMutationInput {
  expiredAt?: DateTimeInput;
  code?: String;
  codeType?: Int;
  phone?: String;
}

export interface NodeNode {
  id: ID_Output;
}

export interface VerificationCodePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  expiredAt: DateTimeOutput;
  code: String;
  codeType?: Int;
  phone: String;
}

export interface VerificationCodePreviousValuesPromise
  extends Promise<VerificationCodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  expiredAt: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
  codeType: () => Promise<Int>;
  phone: () => Promise<String>;
}

export interface VerificationCodePreviousValuesSubscription
  extends Promise<AsyncIterator<VerificationCodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  expiredAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
  codeType: () => Promise<AsyncIterator<Int>>;
  phone: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLogSession {
  count: Int;
}

export interface AggregateLogSessionPromise
  extends Promise<AggregateLogSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLogSessionSubscription
  extends Promise<AsyncIterator<AggregateLogSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LogSession {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  args?: Json;
  ipAddress?: String;
  origin: String;
  resolver: String;
}

export interface LogSessionPromise extends Promise<LogSession>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  args: () => Promise<Json>;
  ipAddress: () => Promise<String>;
  logError: <T = LogErrorPromise>() => T;
  origin: () => Promise<String>;
  resolver: () => Promise<String>;
}

export interface LogSessionSubscription
  extends Promise<AsyncIterator<LogSession>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  args: () => Promise<AsyncIterator<Json>>;
  ipAddress: () => Promise<AsyncIterator<String>>;
  logError: <T = LogErrorSubscription>() => T;
  origin: () => Promise<AsyncIterator<String>>;
  resolver: () => Promise<AsyncIterator<String>>;
}

export interface LogSessionEdge {
  node: LogSession;
  cursor: String;
}

export interface LogSessionEdgePromise
  extends Promise<LogSessionEdge>,
    Fragmentable {
  node: <T = LogSessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LogSessionEdgeSubscription
  extends Promise<AsyncIterator<LogSessionEdge>>,
    Fragmentable {
  node: <T = LogSessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LogErrorConnection {
  pageInfo: PageInfo;
  edges: LogErrorEdge[];
}

export interface LogErrorConnectionPromise
  extends Promise<LogErrorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LogErrorEdge>>() => T;
  aggregate: <T = AggregateLogErrorPromise>() => T;
}

export interface LogErrorConnectionSubscription
  extends Promise<AsyncIterator<LogErrorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LogErrorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLogErrorSubscription>() => T;
}

export interface LogSessionConnection {
  pageInfo: PageInfo;
  edges: LogSessionEdge[];
}

export interface LogSessionConnectionPromise
  extends Promise<LogSessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LogSessionEdge>>() => T;
  aggregate: <T = AggregateLogSessionPromise>() => T;
}

export interface LogSessionConnectionSubscription
  extends Promise<AsyncIterator<LogSessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LogSessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLogSessionSubscription>() => T;
}

export interface AggregateVerificationCode {
  count: Int;
}

export interface AggregateVerificationCodePromise
  extends Promise<AggregateVerificationCode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVerificationCodeSubscription
  extends Promise<AsyncIterator<AggregateVerificationCode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserRefreshTokenPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  expiredAt: DateTimeOutput;
  refreshToken: String;
}

export interface UserRefreshTokenPreviousValuesPromise
  extends Promise<UserRefreshTokenPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  expiredAt: () => Promise<DateTimeOutput>;
  refreshToken: () => Promise<String>;
}

export interface UserRefreshTokenPreviousValuesSubscription
  extends Promise<AsyncIterator<UserRefreshTokenPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  expiredAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  refreshToken: () => Promise<AsyncIterator<String>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  phone?: String;
  password?: String;
  salt?: String;
  userName?: String;
  nickName?: String;
  childName?: String;
  openId?: String;
  unionId?: String;
  birthday?: DateTimeOutput;
  avatar?: String;
  country?: String;
  province?: String;
  city?: String;
  language?: String;
  sessionKey?: String;
  remark?: String;
  gender?: Int;
  deletedAt?: DateTimeOutput;
  forbiddenAt?: DateTimeOutput;
  userStatus?: Int;
  userRole?: Int;
  isChildAccount?: Boolean;
  childAccountForbiddenAt?: DateTimeOutput;
  childAccountForbidden?: Boolean;
  childAccountDeletedAt?: DateTimeOutput;
  childAccountDeleted?: Boolean;
  allowEdit?: Boolean;
  expiredAt?: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  phone: () => Promise<String>;
  password: () => Promise<String>;
  salt: () => Promise<String>;
  userName: () => Promise<String>;
  nickName: () => Promise<String>;
  childName: () => Promise<String>;
  openId: () => Promise<String>;
  unionId: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  avatar: () => Promise<String>;
  country: () => Promise<String>;
  province: () => Promise<String>;
  city: () => Promise<String>;
  language: () => Promise<String>;
  sessionKey: () => Promise<String>;
  remark: () => Promise<String>;
  gender: () => Promise<Int>;
  deletedAt: () => Promise<DateTimeOutput>;
  forbiddenAt: () => Promise<DateTimeOutput>;
  userStatus: () => Promise<Int>;
  userRole: () => Promise<Int>;
  isChildAccount: () => Promise<Boolean>;
  childAccountForbiddenAt: () => Promise<DateTimeOutput>;
  childAccountForbidden: () => Promise<Boolean>;
  childAccountDeletedAt: () => Promise<DateTimeOutput>;
  childAccountDeleted: () => Promise<Boolean>;
  allowEdit: () => Promise<Boolean>;
  expiredAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  phone: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  salt: () => Promise<AsyncIterator<String>>;
  userName: () => Promise<AsyncIterator<String>>;
  nickName: () => Promise<AsyncIterator<String>>;
  childName: () => Promise<AsyncIterator<String>>;
  openId: () => Promise<AsyncIterator<String>>;
  unionId: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  avatar: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  province: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  language: () => Promise<AsyncIterator<String>>;
  sessionKey: () => Promise<AsyncIterator<String>>;
  remark: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Int>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  forbiddenAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userStatus: () => Promise<AsyncIterator<Int>>;
  userRole: () => Promise<AsyncIterator<Int>>;
  isChildAccount: () => Promise<AsyncIterator<Boolean>>;
  childAccountForbiddenAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  childAccountForbidden: () => Promise<AsyncIterator<Boolean>>;
  childAccountDeletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  childAccountDeleted: () => Promise<AsyncIterator<Boolean>>;
  allowEdit: () => Promise<AsyncIterator<Boolean>>;
  expiredAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface VerificationCodeConnection {
  pageInfo: PageInfo;
  edges: VerificationCodeEdge[];
}

export interface VerificationCodeConnectionPromise
  extends Promise<VerificationCodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VerificationCodeEdge>>() => T;
  aggregate: <T = AggregateVerificationCodePromise>() => T;
}

export interface VerificationCodeConnectionSubscription
  extends Promise<AsyncIterator<VerificationCodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VerificationCodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVerificationCodeSubscription>() => T;
}

export interface VerificationCodeEdge {
  node: VerificationCode;
  cursor: String;
}

export interface VerificationCodeEdgePromise
  extends Promise<VerificationCodeEdge>,
    Fragmentable {
  node: <T = VerificationCodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VerificationCodeEdgeSubscription
  extends Promise<AsyncIterator<VerificationCodeEdge>>,
    Fragmentable {
  node: <T = VerificationCodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserRefreshToken {
  count: Int;
}

export interface AggregateUserRefreshTokenPromise
  extends Promise<AggregateUserRefreshToken>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserRefreshTokenSubscription
  extends Promise<AsyncIterator<AggregateUserRefreshToken>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserRefreshTokenSubscriptionPayload {
  mutation: MutationType;
  node: UserRefreshToken;
  updatedFields: String[];
  previousValues: UserRefreshTokenPreviousValues;
}

export interface UserRefreshTokenSubscriptionPayloadPromise
  extends Promise<UserRefreshTokenSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserRefreshTokenPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserRefreshTokenPreviousValuesPromise>() => T;
}

export interface UserRefreshTokenSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserRefreshTokenSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserRefreshTokenSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserRefreshTokenPreviousValuesSubscription>() => T;
}

export interface UserRefreshTokenConnection {
  pageInfo: PageInfo;
  edges: UserRefreshTokenEdge[];
}

export interface UserRefreshTokenConnectionPromise
  extends Promise<UserRefreshTokenConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserRefreshTokenEdge>>() => T;
  aggregate: <T = AggregateUserRefreshTokenPromise>() => T;
}

export interface UserRefreshTokenConnectionSubscription
  extends Promise<AsyncIterator<UserRefreshTokenConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserRefreshTokenEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserRefreshTokenSubscription>() => T;
}

export interface LogError {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  args?: Json;
  resolver?: String;
  errorMsg?: String;
  errorType?: String;
  errorCode?: Int;
  errorArgs?: Json;
}

export interface LogErrorPromise extends Promise<LogError>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  args: () => Promise<Json>;
  resolver: () => Promise<String>;
  errorMsg: () => Promise<String>;
  errorType: () => Promise<String>;
  errorCode: () => Promise<Int>;
  errorArgs: () => Promise<Json>;
  logSession: <T = LogSessionPromise>() => T;
}

export interface LogErrorSubscription
  extends Promise<AsyncIterator<LogError>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  args: () => Promise<AsyncIterator<Json>>;
  resolver: () => Promise<AsyncIterator<String>>;
  errorMsg: () => Promise<AsyncIterator<String>>;
  errorType: () => Promise<AsyncIterator<String>>;
  errorCode: () => Promise<AsyncIterator<Int>>;
  errorArgs: () => Promise<AsyncIterator<Json>>;
  logSession: <T = LogSessionSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LogErrorSubscriptionPayload {
  mutation: MutationType;
  node: LogError;
  updatedFields: String[];
  previousValues: LogErrorPreviousValues;
}

export interface LogErrorSubscriptionPayloadPromise
  extends Promise<LogErrorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LogErrorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LogErrorPreviousValuesPromise>() => T;
}

export interface LogErrorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LogErrorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LogErrorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LogErrorPreviousValuesSubscription>() => T;
}

export interface UserRefreshToken {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  expiredAt: DateTimeOutput;
  refreshToken: String;
}

export interface UserRefreshTokenPromise
  extends Promise<UserRefreshToken>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  expiredAt: () => Promise<DateTimeOutput>;
  refreshToken: () => Promise<String>;
  owner: <T = UserPromise>() => T;
}

export interface UserRefreshTokenSubscription
  extends Promise<AsyncIterator<UserRefreshToken>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  expiredAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  refreshToken: () => Promise<AsyncIterator<String>>;
  owner: <T = UserSubscription>() => T;
}

export interface LogErrorPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  args?: Json;
  resolver?: String;
  errorMsg?: String;
  errorType?: String;
  errorCode?: Int;
  errorArgs?: Json;
}

export interface LogErrorPreviousValuesPromise
  extends Promise<LogErrorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  args: () => Promise<Json>;
  resolver: () => Promise<String>;
  errorMsg: () => Promise<String>;
  errorType: () => Promise<String>;
  errorCode: () => Promise<Int>;
  errorArgs: () => Promise<Json>;
}

export interface LogErrorPreviousValuesSubscription
  extends Promise<AsyncIterator<LogErrorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  args: () => Promise<AsyncIterator<Json>>;
  resolver: () => Promise<AsyncIterator<String>>;
  errorMsg: () => Promise<AsyncIterator<String>>;
  errorType: () => Promise<AsyncIterator<String>>;
  errorCode: () => Promise<AsyncIterator<Int>>;
  errorArgs: () => Promise<AsyncIterator<Json>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLogError {
  count: Int;
}

export interface AggregateLogErrorPromise
  extends Promise<AggregateLogError>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLogErrorSubscription
  extends Promise<AsyncIterator<AggregateLogError>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VerificationCode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  expiredAt: DateTimeOutput;
  code: String;
  codeType?: Int;
  phone: String;
}

export interface VerificationCodePromise
  extends Promise<VerificationCode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  expiredAt: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
  codeType: () => Promise<Int>;
  phone: () => Promise<String>;
}

export interface VerificationCodeSubscription
  extends Promise<AsyncIterator<VerificationCode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  expiredAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
  codeType: () => Promise<AsyncIterator<Int>>;
  phone: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface LogErrorEdge {
  node: LogError;
  cursor: String;
}

export interface LogErrorEdgePromise
  extends Promise<LogErrorEdge>,
    Fragmentable {
  node: <T = LogErrorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LogErrorEdgeSubscription
  extends Promise<AsyncIterator<LogErrorEdge>>,
    Fragmentable {
  node: <T = LogErrorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LogSessionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  args?: Json;
  ipAddress?: String;
  origin: String;
  resolver: String;
}

export interface LogSessionPreviousValuesPromise
  extends Promise<LogSessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  args: () => Promise<Json>;
  ipAddress: () => Promise<String>;
  origin: () => Promise<String>;
  resolver: () => Promise<String>;
}

export interface LogSessionPreviousValuesSubscription
  extends Promise<AsyncIterator<LogSessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  args: () => Promise<AsyncIterator<Json>>;
  ipAddress: () => Promise<AsyncIterator<String>>;
  origin: () => Promise<AsyncIterator<String>>;
  resolver: () => Promise<AsyncIterator<String>>;
}

export interface LogSessionSubscriptionPayload {
  mutation: MutationType;
  node: LogSession;
  updatedFields: String[];
  previousValues: LogSessionPreviousValues;
}

export interface LogSessionSubscriptionPayloadPromise
  extends Promise<LogSessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LogSessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LogSessionPreviousValuesPromise>() => T;
}

export interface LogSessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LogSessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LogSessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LogSessionPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserRefreshTokenEdge {
  node: UserRefreshToken;
  cursor: String;
}

export interface UserRefreshTokenEdgePromise
  extends Promise<UserRefreshTokenEdge>,
    Fragmentable {
  node: <T = UserRefreshTokenPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserRefreshTokenEdgeSubscription
  extends Promise<AsyncIterator<UserRefreshTokenEdge>>,
    Fragmentable {
  node: <T = UserRefreshTokenSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  phone?: String;
  password?: String;
  salt?: String;
  userName?: String;
  nickName?: String;
  childName?: String;
  openId?: String;
  unionId?: String;
  birthday?: DateTimeOutput;
  avatar?: String;
  country?: String;
  province?: String;
  city?: String;
  language?: String;
  sessionKey?: String;
  remark?: String;
  gender?: Int;
  deletedAt?: DateTimeOutput;
  forbiddenAt?: DateTimeOutput;
  userStatus?: Int;
  userRole?: Int;
  isChildAccount?: Boolean;
  childAccountForbiddenAt?: DateTimeOutput;
  childAccountForbidden?: Boolean;
  childAccountDeletedAt?: DateTimeOutput;
  childAccountDeleted?: Boolean;
  allowEdit?: Boolean;
  expiredAt?: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  phone: () => Promise<String>;
  password: () => Promise<String>;
  salt: () => Promise<String>;
  userName: () => Promise<String>;
  nickName: () => Promise<String>;
  childName: () => Promise<String>;
  openId: () => Promise<String>;
  unionId: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  avatar: () => Promise<String>;
  country: () => Promise<String>;
  province: () => Promise<String>;
  city: () => Promise<String>;
  language: () => Promise<String>;
  sessionKey: () => Promise<String>;
  remark: () => Promise<String>;
  gender: () => Promise<Int>;
  deletedAt: () => Promise<DateTimeOutput>;
  forbiddenAt: () => Promise<DateTimeOutput>;
  userStatus: () => Promise<Int>;
  userRole: () => Promise<Int>;
  isChildAccount: () => Promise<Boolean>;
  childAccountForbiddenAt: () => Promise<DateTimeOutput>;
  childAccountForbidden: () => Promise<Boolean>;
  childAccountDeletedAt: () => Promise<DateTimeOutput>;
  childAccountDeleted: () => Promise<Boolean>;
  allowEdit: () => Promise<Boolean>;
  expiredAt: () => Promise<DateTimeOutput>;
  childAccounts: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  parentAccount: <T = UserPromise>() => T;
  refreshTokens: <T = FragmentableArray<UserRefreshToken>>(
    args?: {
      where?: UserRefreshTokenWhereInput;
      orderBy?: UserRefreshTokenOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  phone: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  salt: () => Promise<AsyncIterator<String>>;
  userName: () => Promise<AsyncIterator<String>>;
  nickName: () => Promise<AsyncIterator<String>>;
  childName: () => Promise<AsyncIterator<String>>;
  openId: () => Promise<AsyncIterator<String>>;
  unionId: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  avatar: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  province: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  language: () => Promise<AsyncIterator<String>>;
  sessionKey: () => Promise<AsyncIterator<String>>;
  remark: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Int>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  forbiddenAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userStatus: () => Promise<AsyncIterator<Int>>;
  userRole: () => Promise<AsyncIterator<Int>>;
  isChildAccount: () => Promise<AsyncIterator<Boolean>>;
  childAccountForbiddenAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  childAccountForbidden: () => Promise<AsyncIterator<Boolean>>;
  childAccountDeletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  childAccountDeleted: () => Promise<AsyncIterator<Boolean>>;
  allowEdit: () => Promise<AsyncIterator<Boolean>>;
  expiredAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  childAccounts: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  parentAccount: <T = UserSubscription>() => T;
  refreshTokens: <T = Promise<AsyncIterator<UserRefreshTokenSubscription>>>(
    args?: {
      where?: UserRefreshTokenWhereInput;
      orderBy?: UserRefreshTokenOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface VerificationCodeSubscriptionPayload {
  mutation: MutationType;
  node: VerificationCode;
  updatedFields: String[];
  previousValues: VerificationCodePreviousValues;
}

export interface VerificationCodeSubscriptionPayloadPromise
  extends Promise<VerificationCodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VerificationCodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VerificationCodePreviousValuesPromise>() => T;
}

export interface VerificationCodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VerificationCodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VerificationCodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VerificationCodePreviousValuesSubscription>() => T;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

export type Json = any;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "LogError",
    embedded: false
  },
  {
    name: "LogSession",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserRefreshToken",
    embedded: false
  },
  {
    name: "VerificationCode",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
